공부 자료 : 모두의 네트워크 (미즈구치 카츠야) + 깃허브 + 구글링
***

# 네트워크 개요

### 네트워크, 인터넷

**네트워크 = 둘 이상의 컴퓨터가 연결되고 소통하는 것.**

**LAN (Local Area Network) = 좁은 의미의 네트워크.** 랜 케이블, 와이파이로 연결

**WAN (Wide Area Network) = 넓은 의미의 네트워크.** ISP가 제공하는 서비스로 연결

**인터넷 = 전 세계의 컴퓨터를 연결하는 거대한 네트워크**

***

### ISP 

**Internet Service Provider (인터넷 서비스 제공자).**

SK, KT와 같은 사업자를 의미한다.
집에 설치하는 **공유기가 ISP 와 네트워크를 연결**해준다.

***

### DMZ

![](https://velog.velcdn.com/images/heyksw/post/b810a376-130a-440e-ae34-e675aa7dab43/image.png)


**Dimilitarized Zone 비무장 지대.**
내부 네트워크 -> 외부 네트워크 흐름은 허용하고,
내부 네트워크 <- 외부 네트워크 흐름은 막는 서브넷. 

쉽게말해, **내부 네트워크 중 외부에 오픈한 서버영역**을 말한다.
ex) 웹 서버, 메일 서버, DNS 서버

***

### VPN

**Virtual Private Network = 가상 사설망.**

새로운 가상 네트워크 통로를 만드는 것이다.

예를 들어,
내가 속한 네트워크 : A
VPN 네트워크 : B
접속하려는 네트워크 : X
라고 했을 때

A -> X 다이렉트로 접속하는 경로는 막아두고,
A -> B -> X 로 VPN을 거쳐서 접속하는 경로는 열어두는 경우를 많이 사용한다.

***

### 온프레미스, 클라우드

![](https://velog.velcdn.com/images/heyksw/post/d864d04b-ba6c-427f-aa49-2437012dc48d/image.png)


**On-Premise** -> 사내에 물리적인 서버 기기, 데이터 센터를 두는 방식.

**Cloud** -> 인터넷을 통해 서버 제공


***

### 프로토콜

**프로토콜 = 네트워크 통신을 위한 규칙, 약속, 규약.**

전 세계의 모르는 사람끼리 네트워크 통신을 하더라도 미리 정해진 규약만 있다면 그 규약에 맞춰서 네트워크 통신을 편하게 할 수 있다.

***

### OSI & TCP/IP 모델

![](https://velog.velcdn.com/images/heyksw/post/94d85c8d-3fb9-4b5f-aa4d-4e04d7f599d5/image.png)


**OSI 7계층 모델**
**네트워크 통신을 위한 표준 규격 모델.**
ISO(국제 표준화 기구)에서 지정한 7계층 모델이다.

**TCP/IP 4계층 모델**
**OSI 7계층 모델을 4계층으로 간략화 한 모델.**

**네트워크에서 주고받는 데이터들을 이 계층들을 오르내리면서 캡슐화, 역캡슐화** 된다.
각 계층에서는 그에 맞는 **프로토콜**을 사용한다.

![](https://velog.velcdn.com/images/heyksw/post/565badea-4f23-4076-a47d-7564a3151017/image.png)

https://velog.io/@emplam27

***

# 물리 계층

**Physical Layer : 데이터를 전기 신호로 변환하는 계층**

***

### 랜 카드

![](https://velog.velcdn.com/images/heyksw/post/99147afe-65cf-48fd-9a87-f79b1986354a/image.png)

**데이터를 전기신호로 변환해주는 장치.** 보통 컴퓨터에 내장되어 있다.

***

### 리피터

![](https://velog.velcdn.com/images/heyksw/post/ec2e2ff1-6a20-4d30-ad82-9e8e1448e92b/image.png)

먼 곳에 데이터 통신을 할 때 **파형을 바로잡아주고, 전기 신호 증폭 역할**을 해주는 장치.
최근에 잘 사용하지는 않는다.

***

### 허브

![](https://velog.velcdn.com/images/heyksw/post/91f0097e-124e-4800-b29d-3a59876594dc/image.png)

**1:1 로 통신을 하는 리피터와 달리 1:N으로 여러대의 통신**을 돕는 장치.
리피터와 마찬가지로 **파형을 바로 잡아주고** 데이터가 더 멀리 갈 수 있도록 **전기 신호 증폭**을 돕는다.

**더미 허브 (dummy hub)** 라는 별명이 붙어있는데, 허브를 거치면 무조건 연결 되어 있는 컴퓨터들에게 데이터가 전송돼서, 원하지 않는 컴퓨터에게까지 데이터를 보내기 때문이다.
-> 이 대책으로 **스위치**라는 장치가 등장했다. (데이터 링크 계층)

***

# 데이터 링크 계층

**DataLink Layer : LAN에서 필요한 규격을 체크하는 계층.**

***

### 이더넷 (Ethernet)

**LAN에서 활용되는 네트워크 프로토콜.**
이더넷은 물리 계층에서 신호와 배선, 데이터링크 계층에서 MAC 형식을 정의한다.

***

### CSMA/CD, CSMA/CA

컴퓨터 여러 대가 동시에 데이터를 주고 받으면 데이터들이 **충돌** 할 수도 있다.
이더넷은 CSMA/CD , CSMA/CA 방법을 통해서 충돌을 막는다.

**CSMA(Carrier Sense Multiple Access)**는 네트워크 데이터 전송 전에, 현재 채널 중을 사용중인지를 체크해서 멀티플 액세스가 가능하도록 한느 프로토콜이다.

**1) CSMA/CD**
**Detect → 충돌 감지 방법** 
CD는 **충돌이 발생할 경우 일정 시간 후 재전송** 시킨다.

**2) CSMA/CA**
**Avoidance → 충돌 회피 방법**
CA는 **데이터를 전송하기전에 전송의도를 알리는 신호**를 보낸다.


***

### MAC 주소

**MAC 주소** = 랜 카드에 부여되는 고유한 주소 번호. 전 세계에서 유일한 번호다. 물리주소라고도 한다.
(MAC 주소 48 비트) = (랜 카드 제조사 번호 24 비트) + (제조사가 붙인 일련번호 24 비트)

네트워크 장비 or 컴퓨터는 모두 MAC 주소를 갖는다.
**16진수로 표현**된다. (ex 12:34:56:78:90:AB)

**물리적 주소** 또는 **WiFi 주소** 라고 부르기도 한다.

***

### 이더넷 헤더, 트레일러

데이터링크 계층으로 올라온 데이터에는 앞뒤로 **이더넷 헤더와 이더넷 트레일러가 추가**된다.

**(이더넷 헤더)** = (목적지 MAC주소 6바이트) + (출발지 MAC주소 6바이트) + (이더넷 유형 2바이트)
**(이더넷 트레일러)** = FCS(Frame Check Sequence). 데이터 전송에 오류가 발생했는지 체크하는 용도.

<u>이더넷 헤더와 트레일러가 추가된 데이터를 **프레임**이라고 한다.</u>

***

### 스위치

![](https://velog.velcdn.com/images/heyksw/post/38759cbf-374e-4ad8-9246-f01dce24d557/image.png)


**스위치 = 데이터 링크 계층에서 네트워크 통신을 돕는 장비.**
스위치 안에는 **MAC 주소 테이블**이 존재한다.
이더넷 헤더가 캡슐화 된 프레임이 스위치로 도착하면, **MAC 주소 학습 기능**으로 MAC 주소 테이블을 갱신한다.
스위치의 **포트번호와 MAC 주소**가 매핑되어 저장된다.
MAC 주소 테이블의 **MAC 주소 필터링**을 통해서 컴퓨터끼리 데이터를 주고 받는다.


**플러딩 (flooding)**
맨 처음 스위치의 전원을 켜면 MAC 주소가 세팅되어있지 않은 상태이다.
따라서 **맨 처음에는 도착지 MAC 주소가 업데이트 되어있지 않기 때문에** 포트에 연결된 **모든 MAC주소에 데이터를 전송**한다. 이를 **플러딩**이라고 한다.

***

### 충돌 도메인

**충돌 도메인 = 데이터 충돌이 발생했을 때, 손해를 보는 범위.** 영향을 미치는 범위.

**허브**는 어떤 곳에서 충돌이 난다면 연결된 모든 컴퓨터들이 충돌 도메인.
**스위치**는 충돌이 난 그 한 군데만이 충돌 도메인이다.

***

### 전이중, 반이중

![](https://velog.velcdn.com/images/heyksw/post/02218727-29f1-462a-83a7-b8e464c6dd59/image.png)

**단방향 통신** = 송신 or 수신 중 한가지만 가능
**전이중 통신** = 송신, 수신이 동시에 가능
**반이중 통신** = 송신, 수신이 번갈아서 가능

허브는 반이중 통신, 스위치는 전이중 통신이다.


***

# 네트워크 계층

**Network Layer = WAN 에서의 네트워크 통신을 돕는 계층.** 

데이터 링크 계층이 LAN 에서의 네트워크를 도왔다면, 네트워크 계층은 WAN 을 위한 계층이다.

***

### IP 란

**IP(Internet Protocol)** 란 **인터넷에 연결되어 있는 모든 장치들**(컴퓨터, 서버 장비, 스마트폰 등)**을 식별할 수 있도록 각각의 장비에게 부여되는 고유 주소**이다.

(= **어떤 네트워크의 어떤 네트워크 장비인지를 구분**할 수 있도록 하는 주소)

**LAN에서는 MAC주소 만으로도 통신**할 수 있지만 **다른 네트워크끼리는 MAC으로 통신할 수 없다.**
그래서 MAC주소가 아닌 **네트워크를 식별할 수 있는 다른 주소**가 필요하다. 그 주소가 **IP주소**이다.

**(IP 주소) = (네트워크 ID) + (호스트 ID)**

읽기 편하게 **8비트 옥텟 단위**로 나누며, 10진수로 표시한다.
ex) 143.7.54.203 (= 10001111.00000111.01000001.11001011)

**IP는 ISP에게 할당**받을 수 있다.

***

### IP 헤더의 구조

![](https://velog.velcdn.com/images/heyksw/post/6608c67c-0237-46b4-889c-6f618a0f2111/image.png)


출발지 IP주소, 목적지 IP주소 등 여러가지 정보를 포함한다.

<u>IP 헤더가 붙은 데이터를 **IP 패킷**이라고 한다.</u>

**이더넷** 헤더와 트레일러가 붙은 데이터는 **프레임**이라고 했었다.

***

### IPv4, IPv6

**IPv4 = 32비트** 주소 비트 사용
**IPv6 = 128비트** 주소 비트 사용

32비트로 표현할 수 있는 주소 비트는 유한하기때문에 128비트를 사용하는 IPv6가 등장했다. 128비트로 표현할 수 있는 주소 비트는 거의 무한대이다.

***

### 공인 IP, 사설 IP

![](https://velog.velcdn.com/images/heyksw/post/498a9209-f125-4b7a-8878-34709fe25fb3/image.png)


IPv4 의 **유한한 주소비트 문제를 해결하기 위해** 등장한 개념이 **공인 IP와 사설 IP**다.

**라우터에는 공인 IP주소를 할당**하고, **LAN 안에 속한 호스트들에는 사설망 내부에서만 유효한 사설 IP주소를 할당**한다. 이렇게 하면 **다른 사설망끼리는 중복된 IP주소를 사용해도 문제가 발생하지 않는다.**

사설 IP주소를 할당하는 방법은 2가지가 있다.
1) LAN의 네트워크 관리자가 직접 할당
2) 라우터의 DHCP 활용

**공인 IP주소와 사설 IP주소 매핑**은 **라우터의 NAT테이블**에 의해서 일어난다.
(Network Address Translation)

![](https://velog.velcdn.com/images/heyksw/post/afec476a-83a2-4c8f-9d20-d74dad909f03/image.png)

***

### DHCP

**Dynamic Host Configuration Protocol 동적 호스트 구성 프로토콜.**

**DHCP 서버**에서 **호스트의 IP주소**와 각종 **TCP/IP 프로토콜의 기본 설정**을 호스트에게 자동적으로 제공해주는 프로토콜.

사용자가 PC를 껐다 켜거나, 인터넷이 재설정될 경우, **사용가능한 IP를 자동으로 새롭게 부여하는 방식.**

각 컴퓨터들은 고유한 IP주소를 가져야만 인터넷에 접속할 수 있다. 이 때 DHCP를 사용하게 되면 자동적으로 IP주소를 할당해준다.



https://m.blog.naver.com/xcripts/70121283191
https://rednooby.tistory.com/25

***

### 네트워크 주소, 브로드캐스트 주소

**네트워크 주소** : 호스트 ID 비트 값이 0인 주소

**브로드캐스트 주소** : 호스트 ID 비트 값이 최대값 (111..111)인 주소

네트워크 주소는 그 네트워크의 대표 주소이고, 
브로드캐스트 주소는 그 네트워크에 속한 모든 컴퓨터들에게 한 번에 데이터를 전송할 때 사용되는 주소다.

따라서 네트워크 주소와 브로드캐스트 주소는 자신의 컴퓨터 IP로 설정할 수 없는 고유한 주소다.

***

### IP 주소 클래스

![](https://velog.velcdn.com/images/heyksw/post/2437c5ca-2219-478e-a28f-5510f5cd7f7d/image.png)

네트워크 ID의 크기와 호스트 ID의 크기를 조정해서 표현하는 네트워크의 범위를 조정할 수 있다.
이 네트워크 크기를 **클래스** 라는 개념으로 구분할 수 있다.

네트워크 ID 크기가 작으면 그만큼 광범위의 호스트 네트워크 ID 주소를 표현할 수 있고,
네트워크 ID 크기가 크면 그만큼 소규모의 호스트 네트워크 ID 주소를 표현할 수 있게 된다.

***

### 서브넷

![](https://velog.velcdn.com/images/heyksw/post/6ca8ef94-948f-4c8a-9426-c2e31b1d9ada/image.png)


분할된 네트워크를 **서브넷**이라고 하고, 네트워크를 분할하는 것을 **서브네팅**이라고 한다.
(집합관계 : **서브네팅 ⊂ CIDR**, IP 나누고 합치는 기법을 모두 CIDR이라고 이해하면 된다.)

**(IP 주소) = (네트워크 ID) + (서브넷 ID) + (호스트 ID)**

**[서브네팅 하는 이유]**
예를들어 A클래스 네트워크 에는 2^24 비트 개의 호스트 ID를 부여할 수 있다.
만약 여기서 브로드캐스팅을 사용한다면 1667만 7214대의 컴퓨터에 패킷을 전송하게 될 것이다.
서브네팅을 하면 대규모 네트워크를 작은 네트워크로 분할해서 브로드캐스팅 시 전송하는 패킷의 범위를 좁힐 수 있고, IP 주소를 더 효과적으로 사용할 수 있게 한다.

**[서브넷 마스크]**
IP 주소를 서브넷팅 하면 어디까지가 네트워크 ID이고 어디까지가 호스트 ID인지 구분하기 어려울 때가 있다.
이럴때 **서브넷 마스크** 라는 값을 활용한다.

**서브넷 마스크 = 네트워크 ID와 호스트 ID를 식별하기 위한 값.**
A 클래스 서브넷 마스크 = 255.0.0.0
B 클래스 서브넷 마스크 = 255.255.0.0
C 클래스 서브넷 마스크 = 255.255.255.0

**Prefix 표기법** : 255.255.255.0 = "/24" (비트 1의 개수)



***

### CIDR (사이더)

**Classless Inter-Domain Routing. 클래스 없이 도메인간 라우팅.**
한마디로 네트워크를 **고정된 옥텟 클래스 단위로 나누지 않고 유연하게 나눈다.**

**ip 주소의 prefix를 이용해서 더 유연하게 네트워크 영역과 호스트 영역을 나눌 수 있게 하는 방식**이다.

ip 뒤에 192.168.10.0/24 이런식으로 "/24"를 본적이 있다면? 이것이 바로 **사이더 표기법**.

예전에는 클래스 단위를 사용했었지만, **현대에는 사이더를 더 많이 사용**한다.
**AWS에서는 서브넷을 CIDR 블럭**이라고도 부른다.

IPv4 주소 비트는 32 비트로 한정되어있는데 이 **한정된 비트 내에서 어떻게 효율적으로 비트를 나눠 사용할 것인지** 돕는 과정이다.

https://kim-dragon.tistory.com/9

***

### 라우터 

![](https://velog.velcdn.com/images/heyksw/post/36ef96ab-4636-4b11-aa1a-a3998aec633f/image.png)



**라우터 (Router) = 네트워크 데이터를 전송할 때 어떤 경로로 전송할 것인지 길잡이 역할을 하는 장치.**
라우터를 다른 말로 **게이트웨이**라고도 한다.

소프트웨어 측을 강조할 때는 게이트웨이,
하드웨어 측을 강조할 때는 라우터라고 부른다.

컴퓨터는 다른 네트워크로 데이터를 보낼 때 어디로 전송해야하는 지 알지 못하기 때문에, 네트워크의 출입구를 지정하고 일단은 라우터로 데이터를 전송한다. 그 다음은 라우터에게 맡기는 것.

**라우터 테이블 = 여러가지 경로 정보를 저장한 테이블**

**기본 게이트웨이 (default gateway)** = 기본적으로 설정된 라우팅 경로.

***

### 정적, 동적 라우팅

- **정적 라우팅**
    - **관리자에 의해 라우팅 테이블이 유지/관리** 되는 기법
    - 라우팅 테이블을 서로 교환하지 않기 때문에 대역폭을 효율적으로 쓸 수 있다.
    - 유지보수가 어렵다.


- **동적 라우팅**
    - **라우팅 프로토콜에 의해 자동으로 라우팅 테이블을 구성**하는 기법
    - 동적 라우팅에 라우팅 프로토콜들이 쓰인다.
    - Link State, Distance Vector 등이 있다.

***

### ARP

![](https://velog.velcdn.com/images/heyksw/post/0de2f021-5526-4ca7-b24d-661215cef1a3/image.png)

**Address Resolution Protocol = IP 주소 -> MAC 주소 변환 프로토콜.**

LAN 구간에서는 IP통신을 하는 것이 아니라 MAC통신을 한다. 하지만 맨처음 라우터에는 서버에 대한 MAC주소가 없다.

그러면 라우터는 MAC주소를 찾기 위해 **브로드 캐스팅 방식** (불특정 다수)에게 MAC 주소를 요구하고, 
**ARP 캐시 테이블에 MAC 주소들을 저장**한다.

**ARP 의 반대 역할인 RARP** 도 있다.
**RARP (Reverse ARP) = MAC 주소 -> IP 주소 변환 프로토콜**

***

# 전송 계층 

**Transport Layer : 신뢰할 수 있는 데이터를 전송하고, 어떤 포트로 전송할 것인지 돕는 계층**

**전송 계층의 특징 2가지**
**1) 신뢰성 / 정확성 **- 데이터를 목적지에 정확하게 전달하는 것 → **연결형 통신** (메시지 등)
**2) 효율성** - 데이터를 목적지에 빠르게 전달하는 것 → **비연결형 통신** (게임, 동영상)

**TCP = 전송 계층의 연결형 통신 프로토콜
UDP = 전송 계층의 비연결형 통신 프로토콜**

***

### TCP 란


**Transmission Control Protocol = 연결형 통신 프로토콜.**
**(신뢰성 > 효율성)**

**handshaking 과정을 통해서 신뢰성을 보장**한다.

UDP 에 비해 더 정확한 정보를 정확하지만, UDP에 비해 통신 속도가 느리다.

**TCP에 의해 연결 확립, 재전송 제어, 윈도우 제어**가 일어난다.

SMTP, HTTP, HTTPS, FPS 등 우리에게 친숙한 인터넷 서비스 대부분이 TCP/IP로 이뤄져 있다.
TCP/IP 에서 IP는 데이터 순서, 손실에 고려하지 않는 반면, **TCP는 느리지만 신뢰도가 높다.**

***

### TCP 헤더의 구조

![](https://velog.velcdn.com/images/heyksw/post/cd9f7707-3a1d-4443-a191-d6d21ec186da/image.png)

- **출발지 / 도착지 포트 번호** : 데이터를 어떤 어플리케이션에 전달할 것인지 결정
- **일련 번호 / 확인 응답 번호** : 데이터의 올바른 순서를 보장
- **코드 비트** : handshaking 과정 (연결 확립 과정)에 사용
- **윈도우 크기 비트** : 버퍼의 크기를 나타내는 비트. 윈도우 제어에 사용

- <u>TCP 헤더가 붙은 데이터를 **세그먼트**라고 한다.</u>

***

**TCP 헤더 - 코드 비트 디테일**

![](https://velog.velcdn.com/images/heyksw/post/2af32ec0-68ca-4356-8bad-5086f1b201a7/image.png)

- **SYN = 연결 요청 비트**
- **ACK = 확인 응답 비트**
- **FIN = 연결 종료 비트**

***

### 3-way handshake

![](https://velog.velcdn.com/images/heyksw/post/71805c70-368b-4662-ae05-90ad8ce7e941/image.png)


**TCP 연결형 통신을 하기 전에는 먼저 연결(connection)을 확립해야만 한다.** 
이 **연결을 확립하기 위해서 3-way handshake** 를 한다.

handshake 과정에서 **TCP 헤더의 코드 비트를 사용**한다.

1. **SYN** = 통신을 하기 위해 서버에게 연결 허락을 받아야 하므로, 먼저 SYN 요청

2. **SYN + ACK** = 서버가 연결을 허용하기 위해 ACK 를 보내고, 서버도 클라이언트에게 SYN 연결 요청 

3. **ACK** = 클라이언트가 서버에게 연결 허용

- **왜 하필 3-way 인가, 2-way 는 안될까 ?**
→ **TCP는 양방향성 연결**이기 때문에 **상호 간 패킷을 보낼 수 있다는 것을 확인**하기 위해서 **2-way 가 아닌, 3-way** 수행

***

### 4-way handshake

![](https://velog.velcdn.com/images/heyksw/post/fd767444-fe1e-441c-97c7-9d627fcd7fe0/image.png)

**연결을 끊고, 통신을 종료하기 위해서는 4-way handshake** 를 한다.

1. **FIN** = 클라가 서버에게 연결 종료 요청

2. **ACK** = 서버 확인 응답. 서버는 CLOSE-WAIT 상태가 된다.

3. **FIN** = 서버가 클라에게 연결 종료 요청

4. **ACK** = 클라 확인 응답. 클라는 TIME-WAIT 상태가 된다.

- **연결을 종료할 때는 왜 3-way가 아닌 4-way 인가?**
→ 클라는 할 일을 마쳤다고 하더라도 서버는 아직 클라에게 보내고 싶은 정보가 남아 있을 수도 있다. 그래서 일단 ACK 확인 응답을 보내고, 남은 데이터를 모두 보낸 뒤에 FIN 요청을 보낸다. 이를 CLOSE-WAIT 상태라고 한다.

- **TIME-WAIT 상태란 ?**
→ 클라가 서버로부터 FIN 을 받고 난 후에도 바로 연결을 종료하지 않고 일정시간 동안 기다리는 상태.
서버에서 일부 데이터가 지연되어서 늦게 도착하는 상황 (심지어는 FIN 을 전송하기 전에 보냈던 데이터가 FIN 보다 늦게 도착하는 상황도 있다) 도 있기 때문에 일정시간 동안은 받아줄 시간을 둔다.

***

### 재전송 제어

![](https://velog.velcdn.com/images/heyksw/post/7a0d4a94-c73b-4597-ad07-ca1508a15e7d/image.png)


**재전송 제어 = TCP에서 데이터가 올바른 순서로 도착하지 않으면 재전송 요청해서 올바른 순서를 보장**하는 것.

TCP 헤더의 일련번호 (sequence number), 확인 응답번호 (acknowledge number) 를 이용한다.

Sequence Number = 세그먼트의 순서 번호
Acknowledge Number = 세그먼트를 잘 받았다는 것을 나타내기 위한 번호. 다음 순서에 요구하는 번호를 보낸다.

***

### 흐름 제어 

![](https://velog.velcdn.com/images/heyksw/post/6b2a3204-66c8-4bdb-8eb7-2fc224f5f353/image.png)


**흐름 제어 (Flow Control) = 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법.**
수신측이 더 빠른 것은 문제가 되지 않지만 송신측이 더 빠르다면 데이터 손실이 일어날 수 있다.

**윈도우의 크기 (버퍼의 크기)를 체크해서, 한 번에 여러 개의 데이터를 보낼 수 있도록 한다.**
→ 이를 **슬라이딩 윈도우** (Sliding Window) 기법이라고 한다.
→ 이보다 무식한 방법인 **Stop and Wait** 방법도 있다. 말그대로 매번 전송이 올바로 되었는지 기다리고 확인 하는 방법.

TCP에서는 데이터를 주고 받기 위해서는 상대적으로 시간이 걸리기 때문에, **세그먼트 1개씩 주고 받는 것 보다는 한번에 여러개씩 주고 받는 것이 더 효율적**이다.

그렇다고 세그먼트를 무작정 여러개 보낼 수는 없고, 받는쪽에서 데이터를 쌓을 수 있는 양의 크기 (윈도우 크기 = 버퍼의 크기)가 정해져 있기 때문에, **윈도우 비트에 나타난 윈도우 크기를 마지노선으로 여러개씩** 주고 받는다.

처음 연결을 확립하는 **3-way handshake 과정에서 서로의 윈도우 크기를 파악**한다.

*** 

### 혼잡 제어

**혼잡 제어 (Congestion Control) = 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터 속도를 줄이며 해결하는 것.**

네트워크 내에 패킷의 수가 과도하게 몰리는 현상을 **혼잡**이라고 한다.
만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다.

**흐름제어는 송신과 수신의 입장**에서 전송 속도를 다루는데 비해 **혼잡제어는 호스트와 라우터를 포함한 넓은 관점**의 전송 문제를 다룬다.

**네트워크 혼잡을 감지하는 방법**
→ 라우터에서 오버플로우가 발생하여 데이터가 손실되는지 여부 파악.
→ timeout이 나거나 중복 ACK로 인해 데이터가 손실되는 것.

혼잡 회피 방법에는 **AIMD, Slow Start 크게 2가지 방법**이 있다.

***

### AIMD

![](https://velog.velcdn.com/images/heyksw/post/abe8ed4e-2f4f-43ed-b45c-d5509d6bbe21/image.png)


**AIMD (Additive Increase & Multicative Decrease)**

- 처음에 패킷을 하나씩 보내고, **혼잡이 발생하지 않았다면 혼잡 윈도우의 크기를 1씩 증가**

- **혼잡이 발생했다면 혼잡 윈도우의 크기를 반으로 감소**

- 네트워크 대역폭이 남아돌때도 **윈도우 크기를 너무 조금씩 늘리면서 접근한다는 단점**이 있다.

- 네트워크 혼잡 상황을 **미리 감지하지 못한다는 단점**이 있다.

***

### Slow Start

AIMD 는 최초 임계치까지 도달하는데 선형적으로 증가하는데, 이는 매우 비효율적이다.

**Slow Start 에서는 윈도우 크기를 지수적으로 증가 시키다가, 혼잡이 감지되면 윈도우 크기를 1로 줄여버린다.**

**ssthresh (Slow Start Threshold)**
→ 혼잡 제어 정책에서, 이 지점까지만 slow start 를 사용하겠다는 의미. 그 이후로는 AIMD 방식 사용.
→ Slow Start 를 사용하면 윈도우 크기가 지수적으로 늘어나는데, 어느 순간부터는 윈도우 크기가 기하급수적으로 늘어나 감당하기 힘들어진다. 그래서 ssthresh를 둔다.

threshold : 한계점.

![](https://velog.velcdn.com/images/heyksw/post/f6ea1801-d8ff-4882-bb66-f5275edda2f4/image.png)

→ 실제로는 AIMD, Slow Start 등 여러가지 방법을 섞어서 혼잡 제어를 수행한다.

***

### UDP 란

**UDP (User Datagram Protocol) : 비연결형 통신 프로토콜.**
효율성과 빠른 속도가 중요해서 상대방이 제대로 받았는지 확인 하지 않고 연속적으로 데이터를 보낸다.
**(신뢰성 < 효율성)**

UDP의 장점은 데이터의 신속성이다. 주로 **방송이나 온라인 게임에서 사용**된다.
UDP를 사용하면 랜에 있는 컴퓨터나 네트워크 장비에 **모두 일괄적으로 데이터를 보낼 수 있다. **
이를 **브로드캐스팅**이라고 한다.

<u>UDP 헤더가 붙은 데이터를 **UDP 데이터그램**이라고 한다.</u>

**DNS(Domain Name Service)에서 UDP를 사용하는 이유**
→ 연결을 유지할 필요가 없는데, TCP를 통해 연결을 유지하면 오히려 오버헤드가 커진다.

***

### UDP 헤더

![](https://velog.velcdn.com/images/heyksw/post/50a2443a-eda5-4b78-810f-f1368a037cf0/image.png)

- **출발지 / 도착지 포트번호** : 정확히 어떤 애플리케이션에 데이터를 전달할 것인지.

- **Length** : 길이

- **Checksum** : 오류 검출

- TCP 처럼 handshake 과정이나 흐름제어를 하지 않기 때문에 헤더가 비교적 단순하다.

***

# 응용 계층

TCP / IP 모델에서는 OSI 모델의 **[응용 계층, 표현 계층, 세션 계층]을 합쳐서 응용 계층으로 표현**한다.

**응용 계층 (Application Layer) = 애플리케이션 레벨에서 이해할 수 있도록 네트워크 데이터를 가공하는 계층**

**응용 계층의 대표적인 프로토콜**

- **HTTP** : 웹 사이트 접속

- **DNS** : IP 주소 이름 해석

- **FTP** : 파일 전송

- **SMTP** : 메일 송신

- **POP3** : 메일 수신

***

### HTTP 란

![](https://velog.velcdn.com/images/heyksw/post/569cee48-3d09-476f-b411-73d760e5f3c8/image.png)


**HTTP (Hyper Text Transfer Protocol) = 인터넷에서 데이터를 주고받을 때 사용하는 프로토콜.**

**HTTP 특징**

**1. TCP/IP 기반으로 작동**
	연결형 통신. handshaking 수행.

**2. Connectionless**
	요청에 응답을 받으면 요청을 끊어버린다. 이로 인해 많은 사람들이 웹을 이용하더라도 실제 동시 접속을 최소화하여 더 많은 유저 요청을 처리할 수 있게 된다. 
    
**3. Stateless**
	연결을 끊었기 때문에, 클라이언트의 상태를 유지하지 않는다 (로그인 유무 등).
    이 단점을 해결하기 위해 Cookie, Session, JWT 등이 도입되었다.

**HTTP Request & Response Message 구조**

![](https://velog.velcdn.com/images/heyksw/post/205d6e63-19a5-4b0d-9c4f-1fe96e7e4e5c/image.png)

**Request** = start line / headers / body
**Response** = status line / headers / body

출처 : 코딩 애플

***

### HTTP 1.0, 1.1, 2.0

![](https://velog.velcdn.com/images/heyksw/post/194ac76d-0dca-4909-936b-150016dfcf75/image.png)

**HTTP 1.0**
클라이언트가 요청을 보낼 때마다 연결 (3-way handshake)를 했다가 끊었다가 반복했다.

**HTTP 1.1**
**keep-alive** 도입. 매번 연결을 했다가 끊었다가를 반복하지 않고, 
데이터 교환이 모두 끝나면 연결을 끊는다.
**PipeLining** 도입. 첫번째 요청에 대한 응답을 받기전에 두번째 요청을 보낼 수 있다.

**HTTP 2.0**
**Multiplexed Streams** 도입. 요청을 보낸 순서대로 응답을 받지 않아도 된다.

***

### HTTP 메서드

**1) GET**
- **클라이언트가 서버에게 정보를 요청**하는 메서드
- URL 뒤에 key-value 쌍으로 **query string** 을 포함해서 전송
- **캐시를 사용한다.** 한 번 서버에 GET 요청을 한 적이 있다면, **브라우저 히스토리**에 남는다.

**2) POST**
- **클라이언트가 서버에게 데이터 처리(주로 생성)를 요청**하는 메서드
- 전달할 데이터를 **body 에 담아** 전송
- **캐시를 사용하지 않는다.** 브라우저 히스토리에 남지 않는다.

**3) PUT**
- **리소스 자체를 대체**, 없다면 생성


**4) PATCH**
- **리소스의 일부분만 수정**

***

### HTTP Status Code

![](https://velog.velcdn.com/images/heyksw/post/9f47b8cf-baa9-44d3-908d-461d6e1911b6/image.png)

**HTTP response message 에서는 status code 를 헤더에 포함해서 보낸다.**
**Response 의 간략한 설명**이라고 볼 수 있다.

![](https://velog.velcdn.com/images/heyksw/post/fd1545d2-0e7a-49ac-a7f3-6be1931cc9d7/image.png)

***

### HTTP vs 웹 소켓

![](https://velog.velcdn.com/images/heyksw/post/d17d76f5-caf5-47d7-bcc1-ff7e97e037cc/image.png)

**소켓은 한마디로 '데이터 통신 통로'.**

**HTTP 방식은 매번 요청을 보내야만 서버에게 답변**을 받을 수 있다. (문자에 비유)
**웹 소켓 방식은 소켓을 열기만 하면 서버에게 매번 요청을 보내지 않더라도 원할 때 원하는 정보를 주고 받는다.** (전화에 비유)

**HTTP** = Request / Response
**Web Socket** = Open / Close

**예를들어, 채팅 앱을 개발할때 HTTP로 개발을 한다면? **

유저가 메시지를 보냈는지 1초마다 계속 확인하는 요청을 보내야 할 것이다.

**하지만 웹 소켓으로 개발한다면** 그럴 필요가 없다. 소켓이 열려있는동안 메시지를 보냈는지 실시간으로 확인할 수 있기 때문.

그래서 채팅방, 주식 거래앱, 게임 등에서는 웹 소켓 방식을 활용한다.

사실, 카카오톡 채팅방에서 친구들은 서로에게 직접 연결된 것이 아니라, 각각 웹소켓 서버에 입장한 것이다.

내가 웹 소켓 서버에 메시지를 보내면, 서버는 소켓 통로를 통해 해당 메시지를 채팅방 친구에게 보내주는 것이다.

**그럼 웹 소켓 방식이 무조건 HTTP 방식보다 좋은가 ?**
그렇지 않다. **웹 소켓 방식의 단점은 메모리 파워가 중요해진다는 것**이다.
여러명의 유저들이 웹 소켓 서버에 입장할 수록, 연결을 계속 유지하기 때문에 감당이 힘들어진다.
이는 서버에 돈을 더 사용해야 함을 의미한다.

**그래서 웹 소켓 특징 정리**
- **양방향 통신** - 클라이언트와 서버가 서로에게 원할 때 데이터를 주고 받을 수 있다. 통상적인 HTTP 통신은 클라 요청이 있을때만 서버가 응답하는 방식이었다. Polling 방식이 아니어도 된다.
- **실시간 네트워킹** - 연속된 데이터를 빠르게 노출하기 때문에 채팅, 주식, 비디오 등에 사용한다.
- **Hand Shaking 이 필요**하다. **HTTP 프로토콜**로 Handshaking을 하고 (이때 HTTP Header를 사용한다), 연결 수립이 되었을 때부터는 **ws 프로토콜**을 사용한다. 그리고 ws 도 HTTP/HTTPS 와 똑같이 80/443 번 포트를 사용한다.
- **프레임**이라는 데이터 메시지 단위로 송수신한다.

**Socket.io 란**
- 웹 소켓이 HTML5 이상에서만 지원하기 때문에 HTML5 이전에 개발된 서비스에서 웹 소켓처럼 동작할 수 있도록 도와주는 기술. 웹 소켓은 표준 기술이지만 Socket.io는 라이브러리다.

출처 : 노마드 코더, 우아한 테코톡, 코딩 애플 youtube.

***

### DNS

![](https://velog.velcdn.com/images/heyksw/post/0d13e325-5133-4fee-9f5c-624eefeb6158/image.png)

**DNS(Domain Name System) = ip 주소 와 domain name 변환 시스템.**
**클라이언트가 DNS 서버에게 IP 주소를 묻고, 답변을 받는다.**

**DNS 서버는 계층 구조**로 되어있다.
**최상위 서버 = 루트 네임 서버**

domain name = "https://www.google.com" 
ip 주소 = "72.217.161.174"

![](https://velog.velcdn.com/images/heyksw/post/e23253bf-3369-4cae-9448-2d192c280730/image.png)

**www.naver.com 에 대한 DNS 동작 과정**

1. 클라이언트가 로컬 DNS에게 IP 주소를 묻는다. 알고있다면 답변해준다.

2. 모른다면 Root DNS에 질의한다. 여기부터 로컬 DNS가 통신 창구이다.

3. "아 너는 TLD(Top Level DNS)가 com 이구나, 그럼 com DNS 에게 가봐" 라고 답변준다.

4. com DNS에게 질의한다.

5. naver.com DNS에게 가라고 답변을 준다.

6. naver.com DNS에게 질의한다.

7. IP 주소를 획득한다.

8. 클라이언트에 전송한다.


***


# 네트워크 전체 흐름

### 계층별 주요 프로토콜, 기술

![](https://velog.velcdn.com/images/heyksw/post/bab32a33-16a5-4941-a366-a6035ac008e3/image.png)

![](https://velog.velcdn.com/images/heyksw/post/d3b76d71-c7ee-42af-8e95-12086482d97e/image.png)

***

### google.com 을 주소창에 쳤을 때

![](https://velog.velcdn.com/images/heyksw/post/665c0a5d-b034-4e46-9a0c-6d1a0e074ae0/image.png)


**<u>Q : www.google.com 을 주소창에 쳤을 때 화면이 나오기 까지의 과정을 설명해보세요.</u>**

1) 브라우저 캐시에 IP 주소가 있는지 확인한다.

2) 없다면 Local DNS 에 IP 주소를 묻는다.

3-4) Local DNS 가 모른다면, Root DNS 부터 DNS 계층 구조를 돌아 IP 주소를 획득한다.

5) 웹 HTTP 는 TCP 기반이기 때문에, 서버 - 클라이언트 간의 연결을 위해 handshake 를 한다.

6) 연결이 확립되었으면, 클라이언트에서는 응용계층에서 HTTP Request 메시지를 생성한다. 구글 창을 요청하는 GET 메서드를 사용한다.

7) 계층을 내려오며 패킹한다. 전송 계층에서 포트번호가 담긴 TCP 헤더를 붙여 세그먼트를 만든다. HTTP 는 80번, HTTPS 443번이다.

8) 네트워크 계층에서 DNS 에서 받은 IP 주소가 담긴 IP 헤더를 붙여 IP 패킷을 만든다.

9) 쭉 물리 계층까지 내려와, 랜 카드에서 전기 신호로 변환 후 라우터에 전송한다. 라우터는 구글 서버까지 데이터 길 안내를 해준다.

10) 계층을 쭉 올라오며 데이터를 언패킹한다. 언패킹 결과를 Google 서버에 전달하고 process 처리한다.

11) Google 서버는 클라이언트에서 했던것과 같은 과정으로, HTTP Response 메시지를 만들어 데이터를 패킹 후 전송한다.

12) HTTP Response 에 Status 200과 함께 담긴 메시지를 토대로 HTML 렌더링을 해서 화면에 구글 창이 띄워진다.

***


# 네트워크 보안

### 대칭키, 비대칭키

![](https://velog.velcdn.com/images/heyksw/post/99969c73-a16b-4d08-aa44-7b40d99d875e/image.png)

- **대칭키** = 암호화/복호화에 같은 키를 사용. 연산 속도 빠름.

- **비대칭키** = 암호화/복호화에 다른 키를 사용. (개인키/공개키)

개인키로 암호화 할 경우 : 공개키로 복호화. 개인이 생성했음을 보장 가능.
공개키로 암호화 할 경우 : 개인키로 복호화. 본인만 복호화 가능.

***

### HTTP & HTTPS

**HTTPS (Hyper Text Transfer Protocol Secure)** = HTTP 에서 보안을 추가한 프로토콜.

통신하는 서버가 신뢰할 수 있는 서버인지를 보장한다.

HTTP 포트 : 80 
HTTP 포트 : 443

**[ HTTPS 원리 ]**

HTTPS 연결 과정 hand shaking 에서는 먼저 서버와 클라이언트 간에 세션키를 교환한다.

**세션키**는 주고 받는 데이터를 암호화하기 위해서 사용하는 **대칭키**이며, 데이터 교환에는 빠른 연산속도가 필요하므로 대칭키를 사용한다.

그럼 이 세션키 자체는 어떻게 주고 받는가? → 이 세션키를 **비대칭키** 방식으로 주고 받는다.

즉, 처음 연결을 성립하기 위해서 안전하게 세션키를 공유하는 과정에서 **비대칭키**가 사용되고,

이후에 데이터를 교환하는 과정에서 **대칭키(세션키)**가 사용된다.

***

### HTTPS 연결 과정

![](https://velog.velcdn.com/images/heyksw/post/040747d6-b7c7-46e8-8d4d-1a0eb784dbcd/image.png)


1. 클라이언트가 서버로 최초 연결을 시도함.

2. 서버가 SSL 인증서를 브라우저에게 넘겨줌. 이 인증서에 서버 측 공개키, 서비스 정보 등이 있다. 신뢰할 수 있는 서버임을 보장한다. 서버측의 공개키나 도메인 등등은 인증서를 발급받을 때 CA(Certificate Authority, 인증기관)에 제출해야한다.

3. 브라우저는 미리 갖고 있던 CA의 공개키로 인증서를 까서 유효성을 검사하고, 세션키(대칭키)를 발급 및 보관한다.

4. 인증서 안에 담겨있던 공개키로 세션키를 암호화해서 서버에 전송한다.

5. 서버는 개인키로 암호화 된 세션키를 까서 획득한다.

6. 서버 - 클라이언트는 이제 이 세션키를 가지고 마음껏 데이터를 주고 받는다.

***

### SSL 인증서 발급 과정

1. 서버는 자신의 사이트 정보와 공개키 정보를 CA에게 전달한다.

2. CA는 검증 과정을 거친 후, 자신의 개인키로 사이트 정보를 암호화 해 인증서를 발급한다.

3. CA는 자신의 공개키를 웹 브라우저에 제공한다.

***


# 추가 개념

### Forward Proxy

![](https://velog.velcdn.com/images/heyksw/post/2342ccc8-b15b-405a-828d-a63486710954/image.png)


**프록시 서버 = 클라이언트와 서버 사이에 위치에서 중계 역할을 하는 서버. 통신을 대리 수행하는 서버.**

**포워드 프록시 = 프록시 서버가 클라이언트와 인터넷 사이에 위치.**

**포워드 프록시의 특징**

1. **캐싱** : 캐싱을 활용할 수 있다. 컴퓨터 A가 오늘의 날씨를 서버에게 질의 했었다면, 나중에 컴퓨터 B가 같은 질문을 했을 때 실제 서버까지 가지 않고 프록시 서버에서 답변할 수 있다.

2. **익명성** : 서버 입장에서는 어떤 클라이언트가 요청했는지 알지 못하고 프록시가 요청한 것으로 알게 된다.

https://jamie95.tistory.com/

***

### Reverse Proxy

![](https://velog.velcdn.com/images/heyksw/post/b4ce1b20-f10f-4908-94b0-cf0bc72486e8/image.png)

**리버스 프록시 = 프록시 서버가 인터넷과 서버 사이에 위치**

**리버스 프록시의 특징**

1. **캐싱** : 포워드 프록시의 특징과 동일하다.

2. **보안** : 클라이언트가 요청하고, 프록시 서버가 대신 전달하기 때문에 서버의 실제 IP주소를 노출하지 않고 통신할 수 있다.

3. **로드 밸런싱 (Load Balancing)** : 서버의 부하를 방지한다. 아래서 부연 설명.

***


### 로드 밸런싱 (Load Balancing)

![](https://velog.velcdn.com/images/heyksw/post/85af06c1-99b2-4113-8702-f1c280ed20d9/image.png)

**로드 밸런싱 = 수많은 트래픽이 몰려왔을 때, 서버 부하를 방지하기 위해 서버 여러 대에 일을 분산 시켜 처리하는 방법.**

**로드 밸런싱 서버 선택 알고리즘 종류**
1) Round Robin : CPU 스케줄링의 라운드 로빈 방식과 동일.
2) Least Connections : 연결 개수가 가장 적은 서버 선택.
3) Source : 사용자 IP를 해싱해서 분배. (특정 사용자가 항상 같은 서버를 사용할 수 있도록)

***

### 쿠키 vs 세션

**쿠키 or 세션이 필요한 이유**
HTTP 는 stateless 이기 때문에, 회원이 로그인 했다는 상태 등을 기억하고 있지 않는다.
그렇담 웹 사이트에서 페이지를 넘기고, 매번 새로운 요청때마다 로그인 과정을 거쳐야 할까?
그러지 않기 위해서 쿠키, 세션 도입.

**[ 쿠키 ]**
- 클라이언트 브라우저에 저장되는 key-value 데이터 파일.

- 클라가 서버에게 HTTP reqeust message 를 보낼때 헤더에 쿠키를 담아서 함께 보냄.

- 서버에서 쿠키를 읽었을 때, 쿠키가 업데이트 돼야하는 상황이라면 변경된 쿠키를 HTTP response 헤더에 보내줌.
- 주로 민감하지 않은 정보를 다룸. 지워져도 상관없고, 가로채이더라도 큰 문제가 없는 정보들.
ex) 쇼핑몰 장바구니, 자동 로그인, 하루 보지 않기 등.

- 쿠키는 파일로 저장되기 때문에, 브라우저가 종료되더라도 만료기간까지 남아있다.

**[ 세션 ]**
- 서버에 저장되는 유저 정보. 쿠키를 넣어서 보내기 때문에 쿠키 기반.

- 서버에서는 유저를 구분하기 위한 세션 ID를 발급하고, 서버의 세션 저장소에 저장한다.

- 유저 정보를 서버 측에 두기 때문에 쿠키보다 보안이 좋지만, 서버 자원을 사용해야한다는 단점이 있음.

- 세션은 브라우저가 종료되면 삭제된다.

***

### 쿠키와 세션을 이용한 로그인

![](https://velog.velcdn.com/images/heyksw/post/d93e93e0-81b6-4276-b1b3-ebfd843548b2/image.png)

- **인증 (Authentication)** : 사용자가 누구인지를 확인하는 절차.

- **인가 (Authorization)** : 사용자가 요청하는 것에 대한 권한이 있는지를 확인하는 절차.

1. 클라이언트가 서버에 로그인 요청. 

2. 서버는 회원정보를 대조해서 인증을 함. (Authentication)

3. 서버는 회원 정보 세션을 생성하고 세션 저장소에 저장

4. 서버는 클라이언트를 구분하기 위한 세션 ID 발급.

5. 서버는 http response message 헤더에 세션 ID 를 쿠키에 담아서 크라이언트에게 전송

6. 이제 클라이언트는 세션 ID를 추출해서 쿠키 저장소에 저장하고, 이후에 http request message 를 보낼 때마다 쿠키에 세션 ID를 담아서 전송

7. 서버는 클라이언트가 보낸 세션 ID에 해당하는 정보를 세션 저장소와 대조 (Authorization)

8. 세션 저장소에서 클라이언트 권한 획득

9. 서버는 response 에 그 세션 ID에 걸맞는 데이터 전송


***

### 토큰 (Token)

- **iOS, Android** 에서 세션을 사용할 수 있지만, 쿠키는 사용할 수 없다. 쿠키는 브라우저를 위한 것이기 때문. **쿠키는 네이티브 앱에 없다.**

- 네이티브 앱의 경우, 쿠키 대신에 **토큰을 사용**한다. 토큰은 **just** **String**.

- 클라는 서버에 토큰을 보내고, 서버는 해당 토큰과 일치하는 유저를 찾는다.

- 토큰 중 가장 널리 사용되는 유형은 **JWT** (Json Web Token).

**Access Token & Refresh Token**
- **액세스 토큰** : 말그대로 access 하기 위한 토큰으로, 우리가 흔히 말하는 토큰. 실제 인가를 위한 토큰.
- **리프레쉬 토큰 **: 액세스 토큰이 만료 되었을 때, 사용자가 다시 인증 과정을 거칠 필요 없이 액세스 토큰을 다시 받을 수 있도록 돕는 토큰. 말그대로 액세스 토큰을 갱신하기 위한 토큰이다.

당연하게도 액세스 토큰의 만료기간보다 리프레쉬 토큰의 만료기간이 더 길다.

***

### JWT (Json Web Token)

**세션**은 접속한 유저가 늘어날 때마다 **서버 DB에 세션 ID를 저장**해야만 한다.
그리고 세션 ID 대조를 하기위해 DB를 조회해야하는데, **유저가 많아질 수록 이는 부담**이 된다.

그래서 등장한 것이 **JWT** 방식. 
**JWT 를 사용하면 세션 DB 를 갖을 필요가 없고**, 서버는 유저를 인증한다고 많은 일을 하지 않아도 된다.

**[ 원리 ]**
서버는 특정 유저에 대해 **사인 알고리즘을 사용해서 '사인'**을 한다. 
그리고 **서버는 클라에게 '사인된 정보'를 json string 형태**로 보낸다. 이것이 JWT.

즉, 로그인을 하는데 세션 방식처럼 DB를 건드릴 필요가 없고, 정보를 사인하고 전달해주는게 전부다.

이제 클라가 서버에게 요청을 보내려고 하면 사인된 정보 or 토큰을 서버에 보내야 한다.

서버는 토큰을 받으면 해당 사인이 유효한지 체크한다. DB를 필요로 하지 않는다.

**[ JWT 구조 ]**
- header : 해싱 알고리즘 등의 정보
- payload : 실제 데이터
- signature : 유효성 검증에 필요한 고유한 암호화 코드

JWT 에 대한 좋은 글 : https://velog.io/@neity16/NodeJS-JWT-Token-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0

***

### 세션 vs JWT

**[ 세션 ]** 
- 서버는 로그인 된 모든 유저의 정보를 DB에 저장한다. 

- 이를 통해서 새로운 기능을 창출할 수 있다. 예를들어 강제 탈퇴 시키고 싶을 경우 세션 ID를 삭제해버리면 된다. 혹은 인스타에서 로그인 된 모든 디바이스를 보여준다. 넷플릭스 처럼 계정 공유 숫자를 제한할 수도 있다. 서버가 누가 로그인 했는지 저장했고 세션 DB가 있기 때문에 가능한 일 

- DB 유지 보수가 관건이다. 최근 주로 빠르고 저렴한 redis를 사용한다.

**[ JWT ]** 
- 토큰이 유효한가 아닌가 여부만 체크한다. DB를 따로 두지않는다. 

- 강제 로그아웃 이런 부가적인 기능은 할 수 없다. 

- 한국 코로나 QR 체크인도 JWT 가 들어간 QR 코드이다. 

- 세션이나 DB 없이 유저를 인증한다는 것이 최고의 장점. 하지만 서비스가 더 커지고, 유저 계정을 좀 더 잘 관리하고 싶다면 세션을 쓰는게 좋은 경우가 많다.

출처 : 노마드 코더

***

### OAuth

![](https://velog.velcdn.com/images/heyksw/post/167e492f-c039-44de-abc1-015ed3751c8d/image.png)

**OAuth** : 별도의 회원가입 없이 로그인을 제공하는 플랫폼의 아이디만 있으면 서비스를 이용할 수 있도록 하는 것. 외부 서비스의 로그인 방식을 활용하고 외부 서비스의 API를 이용하게 해주는 것.

**OAuth 의 구성원**
TestApp 이라는 앱을 내가 만들고 싶고, 유저들을 카카오로 로그인 시키고 싶은 상황.
- **Resource Owner** : 유저 = 자원 소유자. 카카오 서비스에 회원가입이 되어있는 유저들.

- **Resouce Server** : 카카오.

- **Authorization Server** : 카카오의 인가 서버. 액세스 토큰을 발급한다.

- **Client** : Test App을 만드는 나 = 카카오 인증 서비스를 이용하는 고객.

카카오의 **유저 액세스 토큰을 발급받아서 카카오 API 를 활용**한다.

***

### URI, URL, URN

![](https://velog.velcdn.com/images/heyksw/post/de856dd2-5579-42b1-b295-91582894f4e3/image.png)

- **URI : (Host) or (Scheme + Host)**

- **URL : (Scheme + Host) (프로토콜을 반드시 포함)**

- **URN** : **(Path)**

![](https://velog.velcdn.com/images/heyksw/post/a1835c8b-ebe6-48fe-aa31-0f23158baf5b/image.png)

- **Scheme**: 리소스에 접근하는 데 사용할 **프로토콜**. 웹에서는 http 또는 https를 사용

- **Host**: 접근할 대상(서버)의 호스트 명

- **Path**: 접근할 대상(서버)의 경로에 대한 상세 정보

***

### Web Server, WAS

![](https://velog.velcdn.com/images/heyksw/post/ed3fcbfe-9fb5-49fd-b327-b96a73dd97e9/image.png)


**[ Web Server ]**
- 인터넷을 기반으로 클라에게 정보나 서비스를 제공하는 컴퓨터
- HTTP 프로토콜을 기반으로 **정적인 컨텐츠** (html, css, jpeg) 를 제공한다.
- ex) Apache Server

**[ Web Application Server ]**
- DB 조회나 다양한 로직처리 등 **동적인 컨텐츠**를 제공하기 위해 만들어진 애플리케이션 서버.
- **(WAS) = (Web Server) + (Web Container)**
- **동적인 요청**이 들어올 때, **Web Server 는 Web Container 에게 전달**한다. 그리고 그 결과를 다시 받아온다.
- 비즈니스 로직 수행 가능
- ex) Tomcat, Jeus


**그러면 그냥 WAS가 Web Server의 기능까지 모두 수행해버리면 안돼?**
1. 정적 컨텐츠, 동적 컨텐츠 역할 분담을 통한 부하 방지
2. 여러 대의 WAS 를 연결 가능. Load balancing.
3. 여러 개의 웹 애플리케이션 사용 가능. 하나의 서버에서 PHP, Java 사용가능.

![](https://velog.velcdn.com/images/heyksw/post/5100dfec-322d-480c-8c88-8648ce97da84/image.png)

**Web Server vs WAS 정리**
Web Server : 정적인 컨텐츠만 처리
WAS : DB 조회나 다양한 로직 등 동적인 컨텐츠 처리

간단하게 '**상황에 따라 변하는 정보를 제공할 수 있는가**' 차이다.


출처 : 우아한 테코톡, https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html

***

### Blocking, Non-Blocking

**Blocking vs Non-Blocking**
- 다른 주체가 작업을 할 때 자신의 제어권이 없는지 있는지.
- ex) 서류를 상사에게 제출하고, 상사 눈 앞에서 아무것도 안하고 기달건지, 다른 일 하러 갈건지.

**Synchronous vs Asynchronous**
- 다른 주체가 결과를 돌려줄 때 순서와 결과에 관심이 있는지 없는지.
- 돌려주면 바로 처리한다 vs 언젠가 처리한다.
- 콜백이 없다 vs 있다
- 내가 직접 관심을 가진다 vs 다른 주체가 끝나면 알려준다
- 일이 끝났는지 내가 직접 계속 체크한다 vs 관심 없다가 남이 알려주면 그런가보다
- ex) 서류를 상사에게 제출하고, 돌려받으면 바로 그 서류를 처리할건지, 아니면 내가 하던일 끝내고 처리할건지.
- ex) 이때 상사 앞에서 기다리던지 내가 할 일 하러 가던지는 상관이 없다. (block / non block 이 아니기 때문에). 내가 그 일에 계속 관심을 갖고 있다는 것이 중요할 뿐.

![](https://velog.velcdn.com/images/heyksw/post/8a189c32-734e-4291-b258-4f7bb06a745b/image.png)

***

### API Gateway

**API Gateway** = **클라에서 서버로 통신할 때 사용하는 많은 API들의 대문. API가 지나가는 통로.**
API 호출 정책, 액세스 제어를 적용하는 **트래픽 관리자 역할**을 한다.

![](https://velog.velcdn.com/images/heyksw/post/04d6e007-4c82-4259-8eab-75a4da11381b/image.png)

여러 서버로 API를 분산시키는 경우가 많다.
클라이언트에서 API를 호출하는 수많은 코드가 적혀있다.

만약 example.com 과 example.org 가 통합된다면 ?
클라이언트의 코드를 모두 변경해줘야 할 것이다.

![](https://velog.velcdn.com/images/heyksw/post/b0dceb7b-4d9c-4e49-85b4-7b5a7ab313e8/image.png)

하지만 중간에 API Gateway 를 둔다면 ?
클라이언트의 코드를 하나도 변경하지 않고 API 경로를 컨트롤 할 수 있다.
그리고 많은 서버들에 대해서 로깅, 액세스 제어, 모니터링, 인증 등의 기능들을 통합적으로 관리할 수 있게 된다.


출처 : 생활 코딩

***


### 무선 랜

![](https://velog.velcdn.com/images/heyksw/post/6a52c796-6942-46d2-9e6f-53bf9f9604b0/image.png)

**무선 랜은 다음 2가지로 이루어진다.**

**1. 무선 액세스 포인트** (= 무선 공유기, 무선 AP)
**2. 무선 클라이언트** (= 노트북, 폰)

**SSID** : 무선 액세스 포인트의 고유한 ID. 와이파이 ID라고 생각해도 된다.
**비컨(beacon)** : 무선 액세스 포인트에서 일정 주기로 전파 신호를 쏘는 장치. 주위의 무선 클라이언트들이 이 비컨의 신호를 잡아 연결한다.
**무선 랜 카드** : 무선 클라이언트 안에 내장되어 비컨의 신호를 잡는 장치.

**무선 랜 연결 방식 2가지**
1. 인프라스트럭쳐 방식 : 무선 액세스 포인트를 중심으로 무선 클라이언트 연결
2. 애드 혹 (Ad Hoc) 방식 : 무선 클라이언트끼리 직접 연결
보통 인프라스트럭쳐 방식을 많이 사용.




